// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: examples/addressbook.proto

#ifndef PROTOBUF_examples_2faddressbook_2eproto__INCLUDED
#define PROTOBUF_examples_2faddressbook_2eproto__INCLUDED

#include <string>
#include <cstdint>
#include <algorithm>
#include <vector>
#include "protobuf/pbf.hpp"

// @@protoc_insertion_point(includes)

namespace tutorial {
class Person;
class Person_PhoneNumber;
class AddressBook;

enum Person_PhoneType {
  Person_PhoneType_MOBILE = 0,
  Person_PhoneType_HOME = 1,
  Person_PhoneType_WORK = 2
};
// ===================================================================

class Person_PhoneNumber {
public:
  inline Person_PhoneNumber();
  inline explicit Person_PhoneNumber(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline Person_PhoneNumber(const Person_PhoneNumber&) = default;
  inline Person_PhoneNumber(Person_PhoneNumber&&) = default;
  inline Person_PhoneNumber& operator = (const Person_PhoneNumber&) = default;
  inline Person_PhoneNumber& operator = (Person_PhoneNumber&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string number = 1;
  static const int kNumberFieldNumber = 1;
  inline bool has_number() const;
  inline const ::std::string& number() const;

  // optional .tutorial.Person.PhoneType type = 2 [default = HOME];
  static const int kTypeFieldNumber = 2;
  inline bool has_type() const;
  inline ::tutorial::Person_PhoneType type() const;

  // @@protoc_insertion_point(class_scope:tutorial.Person.PhoneNumber)
private:
  std::uint32_t _has_bits_[1];
  ::std::string number_ = "";
  int type_ = 1;
};
// -------------------------------------------------------------------

class Person {
public:
  inline Person();
  inline explicit Person(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline Person(const Person&) = default;
  inline Person(Person&&) = default;
  inline Person& operator = (const Person&) = default;
  inline Person& operator = (Person&&) = default;
  #endif

  // nested types ----------------------------------------------------

  typedef Person_PhoneNumber PhoneNumber;

  typedef Person_PhoneType PhoneType;
  static const PhoneType MOBILE = Person_PhoneType_MOBILE;
  static const PhoneType HOME = Person_PhoneType_HOME;
  static const PhoneType WORK = Person_PhoneType_WORK;

  // accessors -------------------------------------------------------

  // required string name = 1;
  static const int kNameFieldNumber = 1;
  inline bool has_name() const;
  inline const ::std::string& name() const;

  // required int32 id = 2;
  static const int kIdFieldNumber = 2;
  inline bool has_id() const;
  inline std::int32_t id() const;

  // optional string email = 3;
  static const int kEmailFieldNumber = 3;
  inline bool has_email() const;
  inline const ::std::string& email() const;

  // repeated .tutorial.Person.PhoneNumber phone = 4;
  static const int kPhoneFieldNumber = 4;
  inline int phone_size() const;
  inline const ::tutorial::Person_PhoneNumber& phone(int index) const;
  inline const std::vector< ::tutorial::Person_PhoneNumber >& phone() const;

  // @@protoc_insertion_point(class_scope:tutorial.Person)
private:
  std::uint32_t _has_bits_[1];
  ::std::string name_ = "";
  ::std::string email_ = "";
  std::vector< ::tutorial::Person_PhoneNumber > phone_;
  std::int32_t id_ = 0;
};
// -------------------------------------------------------------------

class AddressBook {
public:
  inline AddressBook();
  inline explicit AddressBook(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline AddressBook(const AddressBook&) = default;
  inline AddressBook(AddressBook&&) = default;
  inline AddressBook& operator = (const AddressBook&) = default;
  inline AddressBook& operator = (AddressBook&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tutorial.Person person = 1;
  static const int kPersonFieldNumber = 1;
  inline int person_size() const;
  inline const ::tutorial::Person& person(int index) const;
  inline const std::vector< ::tutorial::Person >& person() const;

  // @@protoc_insertion_point(class_scope:tutorial.AddressBook)
private:
  std::uint32_t _has_bits_[1];
  std::vector< ::tutorial::Person > person_;
};
// ===================================================================

// Person_PhoneNumber

inline Person_PhoneNumber::Person_PhoneNumber() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline Person_PhoneNumber::Person_PhoneNumber(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kNumberFieldNumber) {
      number_ = msg.read_string();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kTypeFieldNumber) {
      type_ = msg.read_int32();
      _has_bits_[0] |= 0x00000002u;
    }
    else msg.skip();
  }
}

// required string number = 1;
inline bool Person_PhoneNumber::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline const ::std::string& Person_PhoneNumber::number() const {
  // @@protoc_insertion_point(field_get:tutorial.Person.PhoneNumber.number)
  return number_;
}

// optional .tutorial.Person.PhoneType type = 2 [default = HOME];
inline bool Person_PhoneNumber::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline ::tutorial::Person_PhoneType Person_PhoneNumber::type() const {
  // @@protoc_insertion_point(field_get:tutorial.Person.PhoneNumber.type)
  return static_cast< ::tutorial::Person_PhoneType >(type_);
}

// -------------------------------------------------------------------

// Person

inline Person::Person() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline Person::Person(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kNameFieldNumber) {
      name_ = msg.read_string();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kIdFieldNumber) {
      id_ = msg.read_int32();
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kEmailFieldNumber) {
      email_ = msg.read_string();
      _has_bits_[0] |= 0x00000004u;
    }
    else if (msg.tag == kPhoneFieldNumber) {
      phone_.emplace_back(msg.read_message());
      _has_bits_[0] |= 0x00000008u;
    }
    else msg.skip();
  }
}

// required string name = 1;
inline bool Person::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline const ::std::string& Person::name() const {
  // @@protoc_insertion_point(field_get:tutorial.Person.name)
  return name_;
}

// required int32 id = 2;
inline bool Person::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline std::int32_t Person::id() const {
  // @@protoc_insertion_point(field_get:tutorial.Person.id)
  return id_;
}

// optional string email = 3;
inline bool Person::has_email() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}

inline const ::std::string& Person::email() const {
  // @@protoc_insertion_point(field_get:tutorial.Person.email)
  return email_;
}

// repeated .tutorial.Person.PhoneNumber phone = 4;
inline int Person::phone_size() const {
  return static_cast<int>(phone_.size());
}

inline const ::tutorial::Person_PhoneNumber& Person::phone(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.Person.phone)
  return phone_[index];
}
inline const std::vector< ::tutorial::Person_PhoneNumber >& Person::phone() const {
  // @@protoc_insertion_point(field_list:tutorial.Person.phone)
  return phone_;
}

// -------------------------------------------------------------------

// AddressBook

inline AddressBook::AddressBook() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline AddressBook::AddressBook(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kPersonFieldNumber) {
      person_.emplace_back(msg.read_message());
      _has_bits_[0] |= 0x00000001u;
    }
    else msg.skip();
  }
}

// repeated .tutorial.Person person = 1;
inline int AddressBook::person_size() const {
  return static_cast<int>(person_.size());
}

inline const ::tutorial::Person& AddressBook::person(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.AddressBook.person)
  return person_[index];
}
inline const std::vector< ::tutorial::Person >& AddressBook::person() const {
  // @@protoc_insertion_point(field_list:tutorial.AddressBook.person)
  return person_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tutorial

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_examples_2faddressbook_2eproto__INCLUDED
